# JavaScript 재입문하기(mozilla)   

   
1.JavaScript가 가지고 있는 강력한 언어 기능
-------------------------------------
   
입출력 개념이 없는 JavaScript 언어는 호스트 환경 아래서 스크립트 언어로서 동작하도록 디자인. 외부 세계와 통신하기 위해 호스트 환경이 제공하는 메커니즘에 의존한다. 자바스크립트 인터프리터는 어도비 아크로뱃, 포토샵, SVG images, 위젯 엔진 등의 제품에서 발견할 수 있고, node.js 와 같은 서버 환경에서도 찾을 수 있다. 이렇듯 자바스크립트가 사용되는 영역이 점점 넓어지고 있으며 이 외에도 noSQL 데이터베이스, Apache Couch DB, 임베디드 컴퓨터 같은 데스크톱 환경에서도 사용된다.   

> JavaScript 언어 = 스크립트 언어   


2.JavaScript의 정의
-----------------------
   
자바스크립트는 **유형 및 연산자, 표준 내장 객체 및 메소드가 있는 다중 패러다임 동적 언어**이며 구문은 Java 및 C 언어 기반. 또한 클래스라는 개념이 없어 그 대신 객체 프로토타입을 사용하여 객체지향 프로그래밍을 지원하며 함수형 프로그래밍도 함께 지원한다. 여기서 함수는 객체이며, 실행 가능한 코드를 유지하고 다른 객체와 마찬가지로 전달된다.   
자바스크립트에는 클래스가 없어 기본적으로 상속 기능이 없다. 이를 대신하는 프로토타입으로 상속을 구현하여 사용한다.   
**프로토타입은 함수(function)와 new를 통해 클래스를 대신한다.**   

> 함수 = 객체, 실행 가능한 코드 유지 & 프로토타입 사용   


3.JavaScript 타입
---------------------

수(Number)   
문자열(String)   
부울(Boolean)   
함수(function)   
객체(object)   
기호(symbel)   
정의되지 않음(undefined)   
널(Null)    

`객체(object)`
> 함수(function)   
> 배열(array)   
> 날짜(date)   
> 정규식(RegExp)    


4.수(Number)
----------------   

정수 값은 32bit 정수로 처리되며 일부 구현은 32bit 정수가 아닌 숫자에 유효한 명령어를 수행할 때까지 저장한다.   
   
덧셈, 뺄셈, 계수 또는 나머지 연산을 포함하는 표준 산술 연산자가 지원되며, 고급 수학 함수와 상수를 다루기 위한 수학(Math) 내장 객체가 있다.  
   
내장 parseInt() 함수를 사용하여 문자열을 정수로 변환할 수 있다. parseInt() 함수는 0으로 시작되는 문자열을 8진수로, "0x"로 시작하는 문자열은 16진수로 취급하는데 이 때 8진수는 제거되며 16진수 표기법은 그대로 유지된다. 반면에 내장 함수 parseFloat()는 parseInt()와는 달리 항상 10진수를 사용한다. 단항 연산자 +를 사용하여 값을 숫자로 변환, 문자열이 수가 아닌 경우 NaN(Not a Number)로 불리는 특별한 값을 돌려준다. 다만 어떤 수학 연산의 입력값으로 주어지면 그 결과는 NaN가 된다.   

> parseInt() 함수를 사용해 문자열을 정수로 변환   
```javascript
parseInt('123', 10); // 123
parseInt('010', 10); // 10
```

> 단항 연산자 + 를 사용해 값을 숫자로 변환    
```javascript
+ '42' //42
+ '010'; //10
+ '0x10'; //16
```

> 문자열이 수가 아닌 경우 NaN를 돌려줌  
```javascript
parseInt('hello', 10); //NaN
``` 

내장 isNaN() 함수를 사용해 NaN인지 여부를 검사할 수 있고, 내장 함수 isFinite()를 사용하여 Infinity, -Infinity, NaN 값을 테스트할 수 있다. 추가적으로 isNaN() 함수는 같음 연산(==, ===)을 사용해 판별할 수 없다. 즉, **NaN == NaN, NaN === NaN 이기 때문에 NaN를 판별하는 함수**가 필요하다. NaN 값은 산술 연산이 정의되지 않은 결과 혹은 표현할 수 없는 결과를 도출하면 생성된다. isNaN()의 방법으로는 만일 isNaN(x)가 false을 반환하면 그 식이 NaN을 반환하게 하지 않고 산술식에 x를 쓸 수 있다. true을 반환할 경우, x는 모든 산술식이 NaN을 반환하게 한다. isNaN(x)는 이러한 각각의 조건을 표현하는 가장 짧은 형태이다.  

> 내장 함수 isNaN() 사용해 NaN 여부 검사
```
Infinity, -Infinity, NaN 값 테스트 = 'NaN == NaN', 'NaN === NaN' 이기 때문에 NaN를 판별하는 함수 필요
```

parseInt()와 parseFloat() 함수는 숫자가 아닌 문자가 나올 때까지 문자열을 파싱하고, 그 지점까지 파싱된 숫자를 반환한다. 하지만 '+' 연산자는 중간에 유효하지 않은 문자가 있으면 그대로 문자열을 NaN로 변환한다.   


5.문자열(Strings)
---------------------   

자바스크립트에서 문자열은 유니코드 문자들이 연결되어 만들어진 것이다.   
각 유니코드 문자는 1개나 2개의 코드 유닛으로 표현이 되며 한 개의 문자를 나타내려면 길이가 1인 문자열을 사용하면 된다. 문자열의 길이를 알고 싶다면 해당 문자열의 length 속성(해당 객체가 소유하고 있는 성질을 나타내는 값)에 접근하면 된다.   

> javascript 문자열 = 유니코드 문자들이 연결   
> **문자열의 길이 = length 속성 사용 (해당 객체가 소유하고 있는 성질의 값)**   


6.이외의 타입들
--------------------   

의도적으로 값이 없음을 가리키는 객체 타입의 객체인 `**null**`와 초기화되지 않은 값(아직 그 어떤 값도 주어지지 않은 변수인 '정의되지 않음' 타입의 객체인 `**undefined**`로 구분된다. 자바스크립트에서 변수에 값을 주지 않고 선언하는 것이 가능하다. 이런 경우의 변수 타입은 undefined로 선언한다.   

> null : 의도적으로 값이 없음   
> undefined : 초기화되지 않은, 아직 정의되지 않은 값

true와 false 값(키워드로 예약되어있는 값)을 가질 수 있는 부울 타입을 가지고 있으며 아래의 규칙을 따라 임의의 값을 부울값으로 변환할 수 있다.
   
```
i) false, 0, 빈 문자열(""), 수가 아님을 뜻하는 NaN, null, undefined는 모두 false가 된다.   
ii) 다른 모든 값은 true가 된다.   
```
   
이러한 변환은 Boolean() 함수로 명시적으로 작업을 수행할 수 있다.

```javascript
Boolean('') //false   
Boolean(234) //true   
```

부울연산자는 `&&`(~와, 그리고), `||`(또는), `!`(부정)이 지원된다.   


7.변수(Variables)
---------------------   

자바스크립트에서의 새로운 변수는 `let`, `const`, `var`로 선언된다.   

`let`를 사용하면 블록 유효 범위 변수를 선언할 수 있으며, 선언된 변수는 변수가 포함된 함수 블록에서 사용할 수 있다.   
`const`는 값이 변경되지 않는 변수를 선언할 수 있으며, 변수는 변수가 선언된 함수 블록에서 사용할 수 있다.   
`var`는 가장 일반적인 변수 선언 키워드이며, let, const 키워드가 가지는 제한을 var는 갖지 않는다. 이 키워드로 선언된 변수는 변수가 선언된 함수 블록에서 사용할 수 있다. 만약 변수에 값을 지정하지 않고 변수를 선언하면 타입은 undefined로 지정된다.   

> let : 블록 유효범위 변수 선언 `선언된 변수 > 변수가 포함된 함수 블록에서 사용 가능`   
> const : 값이 변경되지 않는 변수 선언 `변수가 선언된 함수 블록에서 변수 사용 가능`   
> var : 가장 일반적인 변수 선언 
```
let와 const가 가지는 제한을 가지지 않으며 변수가 선언된 함수 블록에서 변수 사용 가능   
변수에 값을 지정하지 않고 변수 선언 : undefined 지정
```

자바스크립트는 **블록에 범위가 없고, 함수에만 범위가 존재**한다. 변수가 복합문에서 var를 사용하여 정의된 경우 전체 함수에서 볼 수 있으며 ECMAScript 2015부터 let 및 const 선언을 사용하면 블록 범위 변수를 만들 수 있다.   

   
8.연산자(Operators)
------------------------
   
자바스크립트의 산술 연산자로는 `+`, `-`, `*`, `/`, `%`(나머지 연산자)가 있다. 값은 `=` 연산자로 할당할 수 있고, `+=`와 `-=`처럼 다른 연산자를 같이 사용해서 할당할 수 있다. 이렇게 쓰인 연산자는 x = x (연산자) y 와 같은 결과를 나타낸다.   
`++`와 `--`를 각각 점진적인 증가와 감소에 사용할 수 있으며, 이들은 전처리 또는 후처리 연산자로 사용될 수 있다.   
'+' 연산자는 문자열을 이어 붙일 수 있다. 문자열에 어떤 수 혹은 다른 값을 더하면 모두 문자열로 바뀌게 된다.   

> javascript 산술 연산자   
`+`, `-`, `*`, `/`, `%`, `=`, `+=`, `-=`, `++`, `--`   
   
> `+` 연산자는 문자열을 이어 붙일 수 있음
```javascript
'1' + 2 + 3 //"123"
1 + 2 + '3' //"33"
```
   
자바스크립트에서의 비교는  `<`, `>`, `<=`, `>=`를 통해 가능하다. 이 연산자들은 문자열과 수 양쪽 모두에서 동작하며 이중 등호(`==`) 연산자는 서로 다른 타입을 줄 경우 타입 강제 변환을 수행하기 때문에 때때로 기대하지 않은 결과를 도출한다. 이렇게 타입 강제 변환을 하지 않도록 하려면 삼중 등호 연산자(`===`)를 사용해야 한다. 이와 비슷하게는 `!=`와 `!==`연산자가 있다.   

> javascript 비교 연산자
`<`, `>`, `<=`, `>=`, `==`, `===`, `!=`, `!==`   


9.제어구조   
--------------
   
자바스크립트는 C 계열의 다른 언어들과 비슷한 제어 구조를 가지고 있다. 조건문은 `if`와 `else`를 지원하는데, 중첩시켜서 사용할 수 있다.   

> 조건문 : if, else > 중첩 가능   

`while` 반복문과 `do-while` 반복문 사용이 가능하며 while 반복문은 단순 반복에, do-while는 반복문이 반드시 적어도 한 번 이상 실행되도록 할 수 있다.   
`for` 반복문은 C와 Java의 반복문과 같다. 이 뜻은 반복문에 필요한 제어 정보를 한 줄에 표현할 수 있다.  

> while : 단순 반복   
> do-while : 반복문이 반드시 적어도 한 번 이상 실행  
> for : 반복문에 필요한 제어정보를 한 줄에 표현 가능    

```javascript
for (let value of array){ //value로 작업을 실행 } : for ...of   
for (let property in object) { //object의 항목(property)으로 작업을 시작 } : for ...in
```

**&&와 || 연산자는 첫번째 식을 평가한 결과에 따라 두번째 식을 평가 실행하는 단축평가 논리**를 사용한다. 객체에 접근하기 전 null 객체인지, 아닌지를 검사하는데 유용하게 사용되며 혹은 틀린 값이 유효하지 않은 값일 때 캐싱 값에 대해서도 사용된다.   
**한 줄로 조건문을 쓸 수 있게 해주는 삼중 연산자도 가질 수 있다.**

```javascript
var allowed = (age > 18) ? "yes" : "no";
```

`switch` 문은 숫자나 문자열을 기반으로 다중 분기되는 문장을 작성하는데 사용될 수 있다. 여기서 `break` 문을 추가하지 않았다면 다음 단계로 넘어가서 실행된다. `default` 문의 적용은 선택사항이며 switch와 case 부분에서 둘 다 표현식을 사용할 수 있다. 이 **switch와 case의 표현식은 === 연산자로 비교**된다.  

> switch : 숫자나 문자열을 기반으로 다중 분기되는 문장을 작성하는데 사용    
> break : 추가하지 않을 경우 다음 단계로 넘어감
> default : 선택사항   

10.객체(Objects)
--------------------
   
자바스크립트의 객체는 간단히 이름-값 묶음의 모임이다. 이 자바스크립트 객체의 모임은 Python의 Dictionaries, Perl와 Ruby의 Hashes, C와 C++의 Hash tables, Java의 HashMaps, PHP의 Associative arrays이며 이러한 데이터 구조가 광범위하게 사용된다. 현재 자바스크립트 내 코어 타입을 제외한 모든 것들은 객체로 취급된다. 값은 객체를 포함하여 아무 자바스크립트 값이 될 수 있는 반면 "이름" 부분은 자바스크립트 문자열로 정의된다. 이 것은 무작위적인 복잡성을 가지는 데이터 구조를 만들 수 있도록 해준다.   

```javascript
var obj = new Object();   
var obj = {};
```

: 의미적으로 동일하며 `var obj = {};` 는 **'객체 리터럴 구문'**이라고 한다. '객체 리터럴 구문'은 JSON 구문의 핵심이다. 이 객체 리터럴 구문으로 객체의 전체적인 구조를 초기화 시킬 수 있고, 속성에 연속적으로 접근할 수 있다.   

11.배열(Arrays)
-------------------
   
자바스크립트에서의 배열은 '특별한 타입의 객체'이다. 일반 객체와 비슷하게 동작하지만 이 배열 객체는 'length' 속성을 가지는데 이는 항상 배열에서 가장 큰 인덱스보다 하나 더 큰 값으로 존재한다. 배열을 생성할 때 보기 편한 배열 표현 방법은 배열 리터럴을 사용한다.   

```javascript
var a = ["A", "B", "C"]
```

**arrary.length는 배열에 들어있는 항목의 수는 반드시 반영하지 않는다.** 배열의 `length 속성`은 `최대 인덱스에 하나를 더한 값`이다. 만일 `존재하지 않는 배열 인덱스를 참조`할 때 `undefined`를 얻게 된다. `for ...in` 루프를 이용하여 배열에 루프를 돌릴 수 있지만 이 방법은 배열 요소를 반복하는 것이 아닌 `배열 인덱스를 반복`한다. 여기서 `Array.prototype`에 새로운 속성을 추가하면 그 속성들 또한 이 루프로 반복된다. 이러한 반복 형태는 배열에 사용하는 것을 추천하지 않는다.   
배열에 대한 또 다른 반복 방법은 `forEach()`이며, 배열에 항목 하나를 추가할 때 예시로 a.push(item);로 하면 된다.

> 배열에 존재하는 몇 가지 메서드   
```javascript
a.toString() //각 항목에 대한 toString()의 출력이 콤마로 구분된 한 개의 문자열을 반환
a.toLocaleString() //각 항목에 대한 toLocaleString()의 출력이 콤마로 구분된 한 개의 문자열을 반환
a.concat(item1[, item[, ...[, itemN]]]) //item들이 덧붙여진 한 개의 배열을 반환
a.join(sep) //배열의 값들을 sep 인자로 구분하여 합친 한 개의 문자열로 반환
a.pop() //배열의 마지막 항목을 반환하면서 제거
a.push(item1, ..., itemN) //배열의 끝에 item들을 덧붙임
a.reverse() //배열의 순서를 거꾸로 배열
a.shift() //배열의 첫번째 항목을 반환하면서 제거
a.slice(start[, end]) //배열의 일부분을 새배열로 반환
a.sort([cmpfn]) //옵션으로 비교용도의 함수를 입력
a.splice(start, delcount[, item1[, ...[, itemN]]]) //배열의 일부분을 제거하고 다른 항목으로 대체하여 배열을 변경
a.unshift(item1[, item2[, ...[, itemN]]]) //배열의 앞쪽에 item를 덧붙임   
...
```
   
   
12.함수(Functions)
-----------------------

객체와 마찬가지로 함수는 자바스크립트를 이해하는데 핵심이 되는 컴포넌트다. javascript 함수는 0 이상의 이름이 있는 매개변수를 가질 수 있으며 함수의 본체는 갯수 제한 없이 구문을 포함할 수 있고 해당 함수에 지역적으로 변수를 보유하도록 선언할 수 있다. `return`문은 언제나 값을 돌려주고 함수의 실행을 끝내는데 사용될 수 있다. `return 문이 없으면`, 혹은 값이 없는 return이 사용되면 javascript는 `undefined`를 돌려준다. = 즉, 기본값을 반환한다. new 키워드로 호출되는 Constructor 생성자의 경우 기본값은 자신의 this 매개변수 값이다. (this는 현재 실행중인 함수를 참조하지 않는다.) 다른 모든 함수의 경우 기본 반환값은 undefined이다.   

> return문이 있을 경우 : 언제나 값을 돌려주고 함수의 실행을 끝내는데 사용   
> return문이 없을 경우(= 값이 없는 return이 사용될 경우) : 기본 값(undefined) 반환   

함수는 추가적으로 주어진 매개변수를 함수 내부에서 접근할 수 있다. 이러한 객체를 `arguments`라고 하며, 해당 함수에 매개변수로 넘겨진 모든 값을 가지고 있는 배열과 비슷한 객체다. 함수는 다른 객체처럼 속성 및 메서드를 가질 수 있기에 다른 객체와 함수를 구별하는 것은 그를 호출할 수 있다는 것이다. 자바스크립트에서의 모든 함수는 function 객체이며, 함수 호출의 매개변수는 함수의 인수다. 함수의 인수는 함수에 값으로 전달되고, 함수가 인수값을 바꾸면 전역 또는 호출한 함수에 반영되지 않는다.   

> 추가적으로 주어진 매개변수를 함수 내부에서 접근 가능한 객체 : `arguments`   

그리고 코드가 점점 길어지고 커질 경우, arguments 배열의 사용을 Rest 파라미터 문법으로 대체함으로 코드 크기는 최소한으로 유지하면서 갯수 제한 없이 함수로 인자를 전달할 수 있다. Rest 파라미터 연산자는 다음과 같은 포맷(...variable)으로 함수 파라미터 목록에 사용된다. 이 variable 인자는 함수가 호출될 때 전달되는 모든 인자를 포함한다. variable 인자에서 반환되는 값을 사용하기 위해 해당 코드에서 for 루프를 for ...of루프로 변경한다.   

avg() 함수는 콤마로 구분된 인자 목록을 받지만 배열의 평균을 알고 싶은 경우 avgArray(arr)로 재작성한다. 여기서 이미 만든 함수를 다시 사용하려면 apply() 메소드를 사용해서 임의의 매개변수 배열을 함수에 넘겨줄 수 있다. 또한 자바스크립트는 익명의 함수를 만들 수 있도록 허용하고 있다.   

```javascript
var avg = function() {...}
```

= `function avg()` 형식과 동일하며, 일반적인 표현식을 사용할 수 있는 어디든 완전한 함수 정의를 넣을 수 있도록 허용하는 것이다.   

재귀적으로 함수를 부를 수 있다. 브라우저 DOM 등에서 볼 수 있는 트리 구조를 다루는데 유용하다. 함수 표현식은 `IIFEs`(즉시 실행 함수 표현)이며 함수 자체 범위에서만 유효하다. 이런 특징은 엔진에 의한 최적화 뿐만 아니라 디버깅 시간을 줄이고 코드 가독성을 높이는데 도움이 된다.
**JavaScript 내의 다른 모든 것들과 마찬가지로 그 자체가 객체이며, 속성을 추가하거나 변경이 가능**하다.   
   

13.사용자 정의 객체
-------------------------
   
옛날 객체지향 프로그래밍에서의 객체는 데이터와 해당 데이터들을 다루는 메소드의 집합이었다. 자바스크립트는 프로토 타입 기반의 언어로, C++나 Java에서 발견할 수 있는 class 구문이 없다. 그 대신에 function를 class로 사용한다.   

`this` 키워드는 함수 안쪽에 사용되면서 현재 객체를 참조한다. 실제로 의미하는 것은 바로 그 함수를 지정하는 것이다. 객체에서 dot 표기법이나 bracket 표기법을 사용해서 부른 경우 해당 객체는 this가 된다. 해당 호출에서 dot 표기법을 사용하지 않은 경우 this는 전역 객체를 참조한다.   

> this : 함수 안쪽에 사용되면서 현재 객체를 참조 = 그 함수를 지정하는 것   
> 해당 호출에서 dot 표기법을 사용하지 않은 경우 `this`는 전역 객체를 참조   

`new` 키워드는 `this`와 깊게 연관되어 있다. 새로운 빈 객체를 만든 다음 지정된 함수를 불러 새로운 객체를 this에 설정하고, this로 지정된 함수는 값을 반환하지 않고 오직 this 객체를 수정한다. **this 객체를 호출하는 곳으로 반환하는 것은 new 이다.** 'new'에 의해 호출되도록 설계된 함수는 constructor(생성자) 함수라고 불린다. Constructor 함수라고 나타내려면 해당 함수의 첫 자를 대문자로 써서 사용해야 한다.

> new에 호출되도록 설계된 함수 : `Constructor`
```
new : this 객체를 호출하는 곳으로 반환
```

`Person.prototype`은 모든 Person 인스턴스들 간에 공유되는 객체이며, lookup(찾아보기) 체인의 한 부분을 이룬다. 이는 Person 객체의 설정되지 않은 속성에 접근을 시도할 때마다 대체용도로 javascript는 Person.prototype에 그 속성이 존재하는지 확인한다. 여기서 Person.prototype에 할당된 모든 것들은 this 객체를 통해 해당 Constructor에 속한 모든 인스턴스 간에 사용가능하도록 한다.   

prototype object의 객체는 언제나 function로 생성되며 함수를 정의하면 함수만 생성되는 것이 아니라 prototype object도 같이 생성된다. 그렇게 생성된 함수는 prototype라는 속성을 통해 prototype object에 접근할 수 있다. 이 prototype object는 일반적인 객체와 같으며 기본적인 속성으로 constructor와 __proto__를 가지고 있다. Constructor는 Prototype object와 같이 생성되었던 함수를 가리키고 있고, __proto__는 Prototype Link이다. Prototype Object는 일반적인 객체이므로 속성을 마음대로 추가 및 삭제를 할 수 있다. __proto__속성은 prototype 속성이 함수만 갖고 있던 것과는 달리 모든 객체가 빠짐없이 가지고 있는 속성이고, 객체가 생성될 때 조상이었던 함수의 Prototype Object를 가리킨다. 이런 속성을 통해 상위 프로토타입과 연결되어 있는 형태를 프로토타입 체인(Chain)이라고 한다. 이런 프로토타입 체인 구조 때문에 모든 객체는 object의 자식이라 불리고, object Prototype object에 있는 모든 속성을 사용할 수 있다. 예를 들면 toString 함수가 있다.   
자바스크립트에서 임의의 프로토타입을 프로그램 내에서 언제든지 변형할 수 있으며, 이미 존재하는 객체에 메소드를 실시간으로 추가할 수 있다.   

```
apply() 와 비슷하게 this를 다시 설정할 수 있게 하는 'call'의 자매 함수
> 인자로 단일 배열이 아니라 확정된 인자 목록을 입력받는다.   
```

내장 함수(Inner functions)란 다른 함수의 내부에서 javascript를 선언할 수 있다. 
```
중첩되는 중요한 세부사항은 부모 함수 범위의 변수에 접근 가능
i) 유지 관리가 좀 더 쉬워지는 코드를 작성하고자 할 때 유용
ii) 한 개 또는 두 개의 함수에서만 호출
iii) 전체 코드 중 다른 부분에서 사용처가 없는 함수라면? : 그 함수 내에 해당 함수 중첩   
```   

**전역 범위 함수의 갯수를 늘리지 않도록 주의**     
이유는 전역 변수 자체가 코드 유지 보수를 어렵게 만들기 때문이다. 반면에 중첩 함수(=지역 전역)는 부모 함수의 범위에서 변수를 공유할 수 있어 전역 변수 이름 공간을 건드리지 않고도 적절한 경우에 함수들을 연동시킬 수 있다.   


14.클로져(Closures)
------------------------   
 
추상적인 개념. 독립적인 (자유) 변수를 가리키는 함수이며, 클로저 안에 정의된 함수는 만들어진 환경을 '기억한다'. = 함수와 함수에 의해 생성되는 범위 객체를 함께 지칭하는 용어이다. 각자의 환경을 가지고 있으므로, 이 환경을 기억하려면 메모리가 소모된다. 클로저를 생성해놓고 참조를 제거하지 않으면 내부 변수가 차지하는 메모리를 회수하지 않으니 클로저 사용이 끝나면 참조를 제거해야 한다.   

다른 함수 내에 정의된 어떤 함수가 외부 함수의 변수에 액세스한다는 점은 내장 함수에서 일어나는 일과 비슷하다. 내장 함수와 다른 점은 외부 함수가 리턴되는데, 여기서 들어있는 변수는 사라진다. = 외부에서 쉽게 접근 가능한 변수를 클로저로 외부에서 변수에 직접 접근하는 것을 제한할 수 있다.   
**자바스크립트 함수가 실행될 때는 언제나 '범위' 객체가 생성되어 해당 함수 내에서 생성된 지역 변수를 저장하고, 함수 매개변수로서 넘겨진 어떤 변수라도 여기에 초기값으로 저장**한다. 이는 모든 전역 변수와 함수가 들어 있는 전역 객체와 비슷하지만 차이점이 있다.   

```
i) 함수가 실행될 때마다 새로운 범위 객체가 생성된다.   
ii) 브라우저에서 윈도우로 접근 가능한 전역 객체와 달리 범위 객체는 자바스크립트 코드에서 직접적으로 액세스할 수 없다. 즉, 현재 범위 객체의 속성에 반복 접근할 수 있는 수단이 존재하지 않는다.   
```

범위 객체는 자바스크립트 객체 체계에서 사용되는 프로토타입 사슬과 비슷한 범위 사슬이라고 불리는 사슬을 형성한다.   
클로져는 상태를 저장할 수 있도록 허용하기 때문에 객체 내부에서 자주 사용될 수 있다.   

클로저의 부작용은 인터넷 익스플로러에서 심각하지 않지만 쉽게 메모리 누출이 된다.  
객체가 생성됨에 따라 메모리가 할당되고, 사용하고 난 메모리는 더 참조하는 다른 객체가 없을 때 되돌아가는 방식으로 동작하는 언어다. 호스트 환경에서 제공되는 객체들은 해당 환경에 의해 다뤄진다.   
메모리 누출은 오랫동안 실행되거나 큰 데이터 구조나 반복, 순환에 의해 누출되는 메모리 양이 많은 경우 고려한다.    
클로져에 의해 발생한 순환 참조를 끊으려면 또 다른 클로져를 추가한다. 이 경우, 내부 함수는 실행되고 나서 바로 사라지므로 `clickHandler`와 함께 생성된 클로져로부터 내용을 숨긴다.   
또 다른 방법은 `window.onunload` 이벤트가 발생하는 동안 순환 참조를 끊는 것이다.   